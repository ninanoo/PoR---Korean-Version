알고리즘에 수학적인 검증이 진행된 후 구현 단계가 진행되길 원했으나 좀 더 많은 분들이 알고리즘을 이해할 수 있도록 실제 동작하는 방식을 먼저 간략히 보이겠습니다.
원래는 간략하게 기본 동작 방식에 대해 시뮬레이션 되어 보일 수 있는 화면을 준비하려 하였습니다.
그런데 이 프로젝트가 저에 본업이 아닌 관계로 시간상 화면이 준비되지는 못했습니다.
우선은 알고리즘을 이해하신 분이면 누구나 구현해 볼 수 있도록 우선 필요한 세부 설계 부분들에 대해 먼저 글로서 기술합니다.

최초 프로젝트 메인 페이지를 통해 새로운 블록체인 알고리즘의 기본 합의 방식을 보였습니다.
합의를 위한 기본 수식과 관련된 내용 정도가 설명되었으나 알고리즘이 확률적으로 분석되지 않았고 그로부터 필요한 관계식이나 확률식 등도 정립되지 않았습니다.

해시함수로부터 생성된 무작위성(randomness)을 갖는 값이 합의를 위해 사용되고 이어지는 확률과정(stochastic process)도 랜덤워크(random walk)의 형태를 갖습니다.
확률변수(random variable)에 난이도가 사용되고 이를 만족하는 다음 후보블록의 수는 확률분포(probability distribution)를 따릅니다.
이 알고리즘은 확률론(probability theory)으로 정의될 수 있고 후보블록 체인의 관련성은 섀넌 엔트로피(Shannon entropy)로 정의될 수 있습니다.
가장 높은 엔트로피(entropy)에서 시작하여 가장 낮은 엔트로피인 가장 큰 정보이득(information gain)이 발생할 때까지 계속해서 합의가 진행됩니다.

알고리즘의 전체 동작이 확률식으로 기술이 되어야하고 그로부터 알고리즘의 각 기준값들이 도출이 되어야 합니다.
이러한 수학적 확률(mathematical probability)로서 다루어지기 위해서는 논문으로 제출되어 학계의 검증과 계속된 연구가 필요한데 아직 진행되지 못했습니다.
개인적인 여건으로 현재는 진행 계획이 없습니다.
다른 많은 합의 알고리즘들과 마찬가지로 테스트넷으로 먼저 구현될 것이고 통계적 확률(empirical probability)로서 접근이 이루어질 것입니다.

테스트넷을 구성하기 위해서는 하나의 시스템이 되기 위한 모든 구조적인 부분들이 설계되어야 합니다.
알고리즘에서 사용되는 기준값들의 책정, 최초 제네시스 블록의 생성, 정보의 전파 방법 등 뿐만 아니라 네트워크의 운영 및 관리 방안과 새로운 정책의 반영을 위한 구조 등이 포함되어야 합니다.
세부 설계에 있어 기밀성이나 인증 과정이 침해받거나 공격에 표적이 될 수 있는 정보의 유출과 같은 보안성이 침해받을 수 있는 부분들이 없어야 하고 분산시스템의 특성을 이용한 분산서비스거부공격 등이 가능한 구간도 없어야 합니다.
블록체인의 근간이 되는 게임이론이 모든 동작에서 유효하도록 'nothing at stake' 등과 같은 문제가 발생하지 않아야 합니다.
탈중앙화라는 기본 목적에 맞게 지역화가 발생하지 않아야 하고 추가적으로 기회의 균등이 이루어지도록 설계됩니다.

확장성 문제를 해결할 새로운 방식이나 최소한 그에 대한 대비가 구조로서 포함되어야 합니다.
확장성을 위한 구조로 현재의 합의 방식에 트리 구조의 분산 체인을 함께 사용하는 방법을 고려하고 있습니다.
분기된 체인을 부분 수렴 시키거나 수렴 시키지 않는 구조로 아직은 인증을 분산시키는 방법이나 체인의 지속성 등과 관련된 부분들이 설계되지 않았습니다.
방향성 비순환 그래프(directed acyclic graph)와는 다른 형태입니다.
첫 구현에 포함되지 않을 수도 있으나 추후 확장 가능하도록 관련된 부분들이 포함될 것입니다.

이 알고리즘은 완전하게 자율화된 네트워크를 목표로 합니다.
그러기 위해선 장애나 예외상황들 뿐만 아니라 네트워크의 확장과 축소, 요구되는 보안수준 등에 대해서도 스스로 대응할 수 있어야 합니다.
우선 적용 사항으로 네트워크의 장애 상황이나 규모의 변화 등에 대응하기 위해 알고리즘 스스로가 네트워크의 상태를 감지하여 그에 맞게 능동적으로 대응하고 적응해 나갑니다.
이 이슈 문서에서 이에 대한 부분이 다루어집니다.

하나의 완전한 시스템이 만들어지는 것을 목표로 하나 아직은 혼자서 진행하고 있는 프로젝트라서 기본 프로젝트 페이지에 새로운 이슈 문서로 필요한 부분들을 하나씩 채워나가고 있습니다.
세부적인 부분들을 진행하면서 기존에 내용이 변경되거나 새로운 내용이 추가되는 경우도 있을 것입니다.
하나의 세부적인 기능 목표에 대해 다양한 방식으로 제안되는 경우도 있을 것입니다.
저에 여가 시간을 할애해 진행하고 있는 프로젝트라서 더디게 진행되고 있습니다.
우선은 테스트넷 이전에 간단하게 코드로 구현하여 시뮬레이션 해볼 수 있도록 이 이슈 문서와 다음 이슈 문서를 통해 몇 가지의 세부 설계를 보입니다.

이 알고리즘에서는 원장에 대한 인증 요청이 발생하기 전에 원장에 대한 인증을 발행할 블록이 미리 선출됩니다.
이를 위해 후보블록체인이 운영되어 매우 많은 수의 후보블록들에 대해 긴 시간에 걸쳐 합의가 진행됩니다.
이 알고리즘의 시간 성능과 공간 성능은 이 후보블록체인을 운영하는 방식에 의해 결정됩니다.
이 문서의 이어지는 내용들에서 언급되는 체인은 모두 후보블록체인으로 이 문서와 다음 문서에서의 주 논의의 대상입니다.
이후로 언급되는 블록 또한 모두 후보블록을 의미합니다.

기본 문서에서 보인 합의에 사용되는 관련성 산출식은 실제로는 두 가지 상황에 대해 기능합니다.
하나는 블록과 블록이 만나는 상황이고 다른 하나는 체인과 체인이 만나는 상황입니다.
체인과 체인이 만나는 상황은 블록과 체인이 만나는 상황을 포함합니다.
이는 분기된 체인들이 수렴되는 과정으로 다음 이슈 문서인 "체인 정보의 동기화"에서 설명됩니다.
네트워크의 모든 노드는 자신이 선택한 하나의 체인 분기에 대해 새로운 블록을 발행합니다.
이는 각 노드의 메인 체인으로 해당 체인의 가장 큰 순서번호의 블록을 기준으로 합의를 진행합니다.
블록과 블록이 만나는 상황은 이 메인 체인에 하나의 새로운 블록이 추가될 때의 경쟁 상황입니다.
관련성 산출식에서 이때의 c 값은 1 로서 뒤따르는 블록이 없으므로 각자의 자체관련성인 2 ^ m 만으로 경쟁합니다.
이 경쟁 상황이 이 이슈 문서에서 다루어지는 내용이고 확률적인 관점에서 평균관련성과 평균전송시간에 대해 설명됩니다.
이를 통해 지역화가 설명되고 또한 그 지역화가 방지되는 기법을 보입니다.

다수의 의견이 모여 정책이 만들어지고 이 정책이 반영되어 시스템의 시간 성능과 공간 성능 그리고 보안성 등의 목표값들이 정해집니다.
이 목표값들을 만족하기 위해 알고리즘의 난이도, 관련성 상수, 관련성 효율비, 임계값, 흐름제어를 위한 시간 기준 등의 기준값들이 조정됩니다.
이 기준값들을 조정하기 위한 정보로 각 블록의 자체관련성과 체인에서의 구간별 평균관련성, 각 블록의 상대전송시간과 체인에서의 구간별 평균전송시간 그리고 마지막 인증블록과 첫 번째 또는 마지막 후보블록 등의 현재 네트워크의 상태를 확인할 수 있는 상태값들이 사용됩니다.
종국에는 이 모든 값들이 시스템의 기능으로서 자동화 되어야 하나 우선은 몇 가지 상태값들을 이용하여 난이도와 시간 기준을 조절해 우선 상용화 가능한 성능이 나올 수 있는 정도의 세부 설계를 보입니다.

암호 응용에 사용되는 해시함수의 특성상 블록체인의 해시값들은 높은 수준의 난수적 성질을 가지면서 인접한 블록의 해시값들 사이에는 상관관계가 존재하지 않습니다.
그러므로 다수의 노드에서 생성되는 해시값들에서 발생 가능한 경우의 수들은 균등한 분포를 갖습니다.
완전한 난수적 성질이 기반이 될 때 두 개의 노드가 나누어 가질 수 있는 가장 작은 값들은 0 또는 1 의 두 개의 값들로 1 비트 길이의 해시값에 대해 충돌이 발생하지 않습니다.
네 개의 노드가 나누어 가질 수 있는 가장 작은 값들은 0, 1, 2 또는 3 의 네 개의 값들로 2 비트 길이의 해시값에 대해 충돌이 발생하지 않습니다.
2 ^ n 개의 노드가 나누어 가질 수 있는 가장 작은 값들은 0 부터 (2 ^ n) - 1 의 2 ^ n 개의 값들로 n 비트 길이의 해시값에 대해 충돌이 발생하지 않습니다.
물론 이는 확률적이나 균등한 분포의 난수적 성질에 기반을 둔 암호학적 특성과 대규모의 분산시스템이라는 특성으로 인해 매우 유효하게 작용합니다.
또한 이 알고리즘은 해시함수의 입력으로 소유정보를 포함합니다.
현재까지의 설계상으로는 새로운 블록에 시간 정보(time stamp)가 포함되지 않습니다.
본문에서는 마지막으로 확정된 인증블록의 정보가 포함된다고 설명되었으나 이 또한 우선 구현되는 부분에서는 제외됩니다.
그러므로 소유정보는 다음 블록에 대한 경쟁에서 해시함수의 입력값들 중 유일하게 구분되는 값이고 또한 이 값은 전체 네트워크에서 각 노드를 유일하게 식별할 수 있는 고유한 값입니다.
같은 메인 체인을 갖는 노드들에서 이전 블록의 해시값은 모든 노드에서 동일하나 소유정보는 각 노드별로 고유하므로 해시함수를 통해 새로 만들어진 해시값도 각 노드별로 고유합니다.
이와 같은 특성들로 인해 네트워크는 전체 노드의 수에 비례하여 충돌이 발생하지 않는 난수의 비트 수를 가질 수 있습니다.
두 개의 노드가 존재하면 네트워크는 충돌이 발생하지 않는 1 비트 길이의 난수를 가질 수 있습니다.
네 개의 노드가 존재하면 네트워크는 충돌이 발생하지 않는 2 비트 길이의 난수를 가질 수 있습니다.
2 ^ n 개의 노드가 존재하면 네트워크는 충돌이 발생하지 않는 n 비트 길이의 난수를 가질 수 있습니다.

이는 반대로 특정한 하나의 값과 일치하는 비트의 길이를 통해 현재 네트워크에 노드의 수를 가늠할 수 있게 합니다.
특정한 하나의 값은 고정된 값이 아닙니다.
충돌이 발생하지 않는 n 비트 길이의 난수에서 임의로 하나의 수를 선택함으로서 노력이 아닌 알고리즘의 선택에 의한 기회의 균등이 이루어지게 합니다.
이전 블록의 해시값이 특정한 하나의 값으로 사용되고 그 값은 매 경쟁마다 예측할 수 없게 변합니다.
각 노드에서 생성된 새로운 해시값과 이전 블록의 해시값에서 일치하는 연속된 비트들의 수로 경쟁이 이루어집니다.
두 개의 노드가 존재하면 이전 블록의 해시값과 1 비트가 일치하는 하나의 노드가 있습니다.
네 개의 노드가 존재하면 이전 블록의 해시값과 2 비트가 일치하는 하나의 노드가 있습니다.
2 ^ n 개의 노드가 존재하면 이전 블록의 해시값과 n 비트가 일치하는 하나의 노드가 있습니다.
2 ^ n 개의 노드가 생성한 블록들 중 하나의 블록을 선택하기 위해 밑이 2 인 이진 로그를 사용하는 lb( 2 ^ n ) 섀넌 비트(shannon bit)로 표현될 수 있고 이로부터 n 비트가 구해질 수 있습니다.
위의 내용을 수학적으로 표현하였으나 이 문서뿐만 아니라 앞으로의 문서들에서도 수학적인 표기보다는 가급적 더 많은 분들이 알고리즘을 이해할 수 있도록 기본 논리를 설명하는 방향으로 서술될 것입니다.

이 문서를 포함하여 이슈로 추가되는 문서들을 통해 설명되는 대부분의 내용들은 프로젝트 메인 페이지에 기본 합의 알고리즘의 이해를 돕기 위한 것들입니다.
하위단의 내용을 보이면서 기본 문서에는 포함되지 않은 몇 가지 세부적인 기법들이 소개될 수는 있으나 알고리즘의 기본 설계가 바뀌지는 않습니다.
체인의 전 주기에 해당하는 전체의 확률 과정을 한 번에 이해하는 것은 쉽지 않습니다.
확률적인 추정에 의한 분산시스템으로 모든 동작이 상관관계에 놓여있고 동시 진행됩니다.
알고리즘의 이해를 돕기 위한 공간 구조와 시간 구조를 보임으로서 전체의 시간과 공간에 걸쳐 동작하는 하나의 확률 과정을 보이는 것이 이슈 문서들의 목적입니다.

위에서 보인 것과 같이 합의를 통해 얻어진 이전 블록의 해시값과 일치하는 비트의 수를 통해 현재 네트워크에 존재하는 노드의 수를 추정할 수 있습니다.
어느 한 순간의 정확한 측정이 아닌 확률적인 추정입니다.
이를 기반으로 하여 실제 구현에서는 체인으로부터의 통계치가 사용됩니다.

네트워크의 노드 수는 시간이 경과함에 따라 증가하거나 감소합니다.
일치하는 해시 비트 수를 통해 노드들의 양적 변화를 감지할 수 있고 이를 알고리즘에 반영함으로서 알고리즘 스스로 네트워크의 변화에 적응하게 할 수 있습니다.
이 정보는 체인으로부터 얻어질 수 있고 이는 다시 체인에 반영될 수 있습니다.
이를 통해 알고리즘의 기준값들을 제어하여 요구되는 목표값들을 일정한 수준으로 유지시킬 수 있습니다.

각 노드는 각자의 체인 정보를 사용하여 각 후보블록들에서 연속된 일치하는 해시 비트들의 수에 대한 산술평균을 구할 수 있습니다.

![averageRelevanceFormula](https://raw.githubusercontent.com/ninanoo/PoR---Korean-Version/master/averageRelevanceFormula.png "averageRelevanceFormula")
```
n : sequence number
i : sequence number of first candidate block
j : sequence number of last candidate block
m : number of consecutive bits with the same value as the previous hash value starting from the beginning
a : average of consecutive hash bits with the same value
```

이 값은 각 블록의 자체관련성으로부터 구한 평균관련성입니다.
이 평균관련성으로부터 최근에 네트워크의 노드에 수를 추정할 수 있습니다.
측정이 아닌 추정입니다.
실제 체인의 자체관련성은 위쪽의 블록들과 아래쪽의 블록들이 갖는 값의 분포가 다릅니다.
그러므로 실제 구현 시에는 이에 대한 비율이 적용되어 사용됩니다.
이렇게 구해진 평균관련성을 다시 다음 블록 생성을 위한 난이도로 사용함으로서 다음 경쟁에서 발생할 수 있는 체인에 분기 정도를 조절할 수 있습니다.

평균관련성은 임계값 만족에 기여하고 있는 네트워크에 노드들의 수에 대한 어느 한 시간 구간에서의 평균값입니다.
본문에서 가정한 관련성 상수나 임계값 등을 기준으로 할 때 적게는 1000 에서 10000 개의 블록들이 평균관련성을 위한 표본으로 사용됩니다.
이 시간 구간은 새로 추가된 후보블록이 인증을 발행하기까지 소요되는 시간으로 본문에서 보인 네트워크를 기준으로 할 때 짧은 경우라 하더라도 몇 시간에 해당합니다.
임계값 만족을 위한 블록들의 수나 인증을 발행하기까지의 시간 구간은 네트워크 규모의 변화나 목표값의 변경 등에 영향을 받습니다.
이 알고리즘이 사용되는 블록체인은 조정에 의해 한 번에 커지거나 작아지는 네트워크가 아니라 자발적인 참여에 의해 서서히 증가하거나 감소하는 네트워크를 가정합니다.
위 시간 구간에 해당하는 통계치가 사용되므로 급격한 네트워크 규모의 변화가 발생할 경우 어느 정도의 시간차는 있더라도 체인은 변경된 네트워크 규모에 서서히 적응해 나갑니다.

평균관련성은 첫 후보블록이 인증블록으로 바뀔 때나 새로운 후보블록이 추가될 때 마다 조금씩 변합니다.
어느 한 순간에 각 노드에서의 평균관련성이 정확하게 같지도 않습니다.
이는 체인의 분기 정도에 따라 확률적으로 변하나 하나의 네트워크에서 동일한 시간대에 분기된 체인들이므로 그 차이가 크지는 않습니다.
그에 따라 난이도도 모든 시간과 공간상에서 고정되어 있지 않으므로 새로운 블록의 생성에 그 값이 포함되지 않습니다.
모든 블록에는 명확하게 검증될 수 있는 최소의 정보들만이 데이터로서 포함됩니다.
난이도는 현재 체인의 상태를 나타내는 값들로부터 만들어져 각 노드가 자체적으로 계산하여 가지고 있는 상대적인 값입니다.
실제 값을 주고받아 일관된 정보로 공유되어 사용되는 것이 아니라 동일한 계산법에 의해 일관되게 추정되어진 확률적인 값이 사용됩니다.
이 알고리즘에서 다루어지는 목표값과 기준값 그리고 상태값들은 이러한 방법으로 관리됩니다.

다음 후보블록을 생성할 수 있는 자격에 대한 기준값으로 난이도가 사용됩니다.
난이도를 사용하지 않을 경우 모든 노드가 다음 후보블록을 생성할 수 있는 자격을 갖습니다.
그러나 긴 시간 동안 이어지는 끊임없는 합의 과정에서 낮은 자체관련성을 갖는 블록들은 대부분 초반의 경쟁에서 탈락합니다.
최초의 난이도의 목적은 이러한 불필요한 경쟁 상황으로 인한 소모적인 체인의 분기를 줄여 네트워크의 효율을 높이는 것이었습니다.
그러나 여기서부터는 동적으로 조절되는 난이도를 사용하여 체인에 분기 정도를 조절합니다.
뒤에서 이어질 지역화와 관련된 내용으로 체인에 분기 정도는 인증이 발행되는 속도와 비례 관계에 있습니다.
그러나 어느 수준을 넘어서면 분기된 체인의 관리에 과부화가 발생하고 네트워크에 병목이 발생합니다.
뒤에서 좀 더 다루어질 내용으로 이러한 관계의 전환점에서 최대로 성능이 발휘될 수 있습니다.
이와 같이 동적으로 조절되는 난이도에 의해서도 체인의 성능이 조절될 수 있습니다.
그렇더라도 인증이 발행되는 속도에 직접적이면서 가장 크게 작용하는 기준값은 관련성 상수나 임계값 등입니다.
동적으로 조절되는 난이도는 어느 한 순간에 네트워크와 체인의 공간 성능을 조절합니다.

평균관련성에서 일정 비트 수를 차감하여 다음 후보블록을 위한 난이도를 구합니다.
이 차감되는 일정 비트 수는 체인의 분기 정도를 조절하는 섀넌 비트로 분기 지수(branch quotient)로 사용됩니다.

```
a : average of consecutive hash bits with the same value (a >= 0)
b : branch quotient in bits (b <= a)
d : number of difficulty bits (d <= a)

d = a - b
```

0 의 분기 지수가 사용되면 단 하나의 노드만이 다음 블록을 생성할 수 있어 체인 분기가 발생하지 않습니다.
1 의 분기 지수가 사용되면 두 개의 노드가 다음 블록을 생성할 수 있어 두 개의 체인 분기가 발생할 수 있습니다.
2 의 분기 지수가 사용되면 네 개의 노드가 다음 블록을 생성할 수 있어 네 개의 체인 분기가 발생할 수 있습니다.
b 의 분기 지수가 사용되면 2 ^ b 개의 노드가 다음 블록을 생성할 수 있어 2 ^ b 개의 체인 분기가 발생할 수 있습니다.
그러나 실제 네트워크에서는 0 의 분기 지수가 사용되더라도 체인에 분기가 발생할 수 있습니다.
위에 보인 것은 가장 이상적인 상황에서 확률에 의해 예측되어질 수 있는 값들입니다.
체인의 분기 정도를 예측이 아니라 좀 더 실제에 근접하여 측정되어지는 상태값이 다음 이슈 문서에서 다루어지나 이 또한 확률적인 값입니다.

균일하게 분포하는 네트워크에서 각 노드에서 생성되는 다음 블록의 해시값은 균일하게 분포합니다.
전체 네트워크에서 체인에 추가될 수 있는 다음 블록은 암호 알고리즘의 난수적 성질에 기반을 두어 결정적으로 선택됩니다.
그로 인해 다음 블록을 체인에 추가할 수 있는 노드들은 이미 정해져 있고 네트워크 공간상에 균일하게 분포합니다.
새로 생성된 블록들이 다른 노드들로 전파되기 위한 시간차로 인해 신규 블록을 발행하는 노드들은 각각 자신의 지역(zone)을 갖습니다.
네트워크에서 균일하게 분포하는 이 노드들은 서로 일정한 거리 간격을 갖게 되고 각 노드의 지역들도 균일한 크기의 영역을 갖습니다.
여기까지는 노력이 아닌 알고리즘에 의한 선택이므로 이로 인해 지역화가 발생하지는 않습니다.
그러나 빠른 참여를 위한 적극성은 마찬가지로 지역적으로 균일한 분포로 선택되는 다음 블록에 의해 일시적인 지역화가 발생하게 합니다.
이 알고리즘에서는 빠른 처리속도를 위해 좀 더 빨리 적극적으로 합의에 참여하는 노드에게 기회가 더 주어집니다.
이는 이 알고리즘의 기반이 되는 게임이론 중 하나로 알고리즘이 멈추어 서는 일 없이 영구히 동작하게하기 위한 것이기도 합니다.
이로 인해 발생하는 분기된 체인들을 위해 누적관련성이 사용되고 계속되는 수렴 과정을 거치면서 합의가 이루어집니다.
경우에 따라서는 참여에 대한 적극성을 노력으로 볼 수도 있고 알고리즘의 기준값들에 의해 이 노력에 대한 비율이 조정됩니다.

체인의 분기와 마찬가지로 네트워크가 지역으로 나누어지는 것도 알고리즘이 허용하는 순기능입니다.
분기되는 체인의 가지들로 인해 네트워크는 지역으로 나누어집니다.
대규모로 확장될 수 있는 네트워크는 지역 단위로 계층화되어 효율적으로 관리됩니다.
체인의 분기를 허용함으로 인해 공간 성능과 동기화 문제가 발생하고 알고리즘은 이를 제어합니다.
지역의 허용도 마찬가지로 지역화 문제를 발생시키고 이것 또한 알고리즘에 의해 제어됩니다.
이에 대한 내용들은 이 문서의 이어지는 내용과 다음 문서의 내용을 통해 설명됩니다.

각 노드 사이의 전송시간의 차이로 인해 네트워크가 체인의 분기 수만큼의 지역으로 나누어집니다.
1 의 분기 지수가 사용되어 다음 블록을 추가할 수 있는 두 개의 노드가 선택되면 전체 네트워크 공간이 두 지역으로 나누어집니다.
2 의 분기 지수가 사용되어 다음 블록을 추가할 수 있는 네 개의 노드가 선택되면 전체 네트워크 공간이 네 지역으로 나누어집니다.
b 의 분기 지수가 사용되어 다음 블록을 추가할 수 있는 2 ^ b 개의 노드가 선택되면 전체 네트워크 공간이 2 ^ b 개의 지역으로 나누어집니다.
균등한 크기로 나누어진 지역과 빠른 참여를 위한 적극성으로 인한 지역화는 분기된 각 체인에 또다시 분기가 발생하게하고 전체 체인의 가지 수는 지수 증가합니다.
지역화가 존재할 때 체인의 지수 증가는 한정된 네트워크 공간을 내부적으로 계속해서 더 작은 지역들로 나누어지게 할 수 있습니다.
프랙탈(fractal) 패턴으로 공간이 분할될 수 있고 그때의 분할 비율인 프랙탈 차원(fractal dimension)은 분기 지수가 될 것입니다.
지역의 크기가 작아질수록 각 지역에 포함되는 노드들에 수도 줄어듭니다.
이는 단순히 부에 편중만이 아니라 확률 공간(probability space)의 사건에 빈도가 기하급수적으로 작아지게 만들어 확률적인 추정에 근거하는 알고리즘의 기반 논리를 약하게 만듭니다.
그러나 이러한 자기 유사성은 바로 이전 블록의 자체관련성이 아니라 후보블록체인 전체 블록들에 대한 평균관련성을 사용함으로서 방지됩니다.
여기에 전송시간에 대한 제어가 함께 작용하여 공간은 내부적으로 분할되지 않습니다.
하나의 분기로부터 또 다른 분기가 발생하는 상황에서의 공간 분할은 시간 제어에 대한 설명이 진행된 후 이 문서의 후반부에서 다루어집니다.
평균관련성의 사용과 함께 선제적 장치로서 뒤에서 설명될 확률적 오차에 대응하기 위한 기법과 지역화를 방지하는 기법 등도 사용됩니다.
또한 체인의 분기와 동시에 분기된 체인들은 계속되는 합의를 거쳐 하나의 체인으로 수렴됩니다.
분기와 수렴의 동시 진행으로 전체 체인의 가지 수는 경쟁 상태(race condition)에 놓이게 되고 체인의 공간 성능은 유동적으로 변합니다.
이에 대한 정도는 알고리즘의 기준값들에 의해 조절되나 외부 요인인 원장에 대한 인증 요청의 발생 빈도에도 영향을 받습니다.
임계값이 만족되기 전까지는 계속해서 체인의 분기와 수렴이 일어납니다.
그러나 임계값이 만족된 후 원장에 대한 인증블록이 발행되기 전까지는 신규 블록의 추가가 없으므로 더 이상 체인의 분기는 발생하지 않고 수렴만이 계속해서 진행됩니다.
이는 순간적으로 한계 수준을 넘어설 수 있는 체인의 가지 수에 대한 방지 장치입니다.
이에 대한 제동 장치는 다음 이슈 문서의 분기된 체인의 수렴에서 다루어집니다.
다음 문서에서 설명될 내용으로 분기된 체인들의 동기화를 위해 블록들의 묶음 단위에 대해 일정 시간 간격으로 분할 전송이 이루어집니다.
이를 위해 각 노드에서는 동적 버퍼링이 이루어지고 이는 네트워크의 부하 정도와 함께 체인의 공간성능을 결정짓습니다.
묶음의 크기와 시간 간격 그리고 버퍼의 크기 등도 현재 체인의 상태로부터 동적으로 조절됩니다.
이는 분산서비스거부공격의 방지와도 관련된 내용으로 다음 문서에서 좀 더 자세히 다루어집니다.

위에서 보인 것과 같이 분기 지수가 작아지면 체인의 가지 수가 적어져 공간 성능이 높아지고 분기 지수가 커지면 체인의 가지 수가 많아져 공간 성능이 낮아집니다.
그러나 시간 성능은 이와 반대로 작용합니다.
분기 지수가 작아져 지역의 수가 적어지면 전체 네트워크에서 하나의 지역이 차지하는 영역은 커집니다.
하나의 지역은 하나의 합의가 진행되는 기본 단위입니다.
커진 지역으로 인해 하나의 블록이 전송되기 위한 거리가 길어져 하나의 합의를 위한 전송시간도 커집니다.
이로 인해 체인에 블록이 추가되는 속도가 낮아져 임계값이 충족되는데 더 오랜 시간이 소요됩니다.
이와 같이 인증 발행의 속도를 높이기 위해서는 큰 분기 지수를 사용하여야 하나 소모적인 체인의 분기로 불필요한 시스템의 자원 낭비를 막기 위해서는 작은 분기 지수를 사용하여야 합니다.
이와 관련하여 분기 지수를 운용하는 방법에는 세 가지가 있습니다.
지금까지 예제로 보인 것은 정책에 따라 고정된 분기 지수를 사용하면서 동적으로 값이 변하는 평균관련성에 비례하여 동적으로 변경되는 난이도를 사용하는 방법이었습니다.
네트워크 규모가 커지더라도 분기 지수가 고정되므로 전체 지역의 수와 체인에 공간 성능은 고정됩니다.
대신 하나의 지역이 차지하는 영역의 크기가 커지므로 하나의 합의를 위한 전송시간이 길어지고 이로 인해 체인에 시간 성능은 감소합니다.
이 방법은 상대적으로 네트워크의 공간 성능이 중요시되는 IoT 환경의 저전력 네트워크 등에서 고려될 수 있으나 일반적인 환경에서는 사용되지 않습니다.
다른 방법으로는 정책에 따라 고정된 난이도를 사용하면서 동적으로 값이 변하는 평균관련성에 비례하여 동적으로 변경되는 분기 지수를 사용하는 방법입니다.
이 방법은 난이도가 고정되어 하나의 지역에 대한 노드 수가 고정되고 각 지역의 크기도 변하지 않으므로 네트워크 규모가 커지더라도 체인에 시간 성능은 일정하게 유지됩니다.
그러나 체인에 분기 지수가 동적으로 변하므로 네트워크 규모가 커지면 분기 지수가 커져 전체 지역의 수는 증가하고 공간 성능은 감소합니다.
마지막은 위 첫 번째와 두 번째 방법을 절충한 것으로 분기 지수와 난이도가 일정한 비율을 유지하면서 평균관련성에 비례하여 두 값이 같이 변하는 방법입니다.
이때는 네트워크 규모가 커지면 위 두 방법에 비해 더 작은 변화량으로 시간 성능과 공간 성능이 함께 일정 비율로 감소합니다.
우선 구현 시에는 두 번째나 세 번째 방법이 적용될 것입니다.
지금까지 보인 내용으로 보면 네트워크 규모가 커질수록 체인에 성능은 감소합니다.
이는 분기 지수와 난이도가 성능에 미치는 영향만을 살펴본 것으로 실제 인증이 발행되는 속도는 이들보다는 관련성 상수나 임계값에 더 직접적인 영향을 받습니다.
높은 난이도가 사용되면 임계값은 더 빠르게 높아집니다.
네트워크에 규모가 커지면 보안성이 더 높아지고 확률적인 기반 논리도 더 유효해집니다.
그에 따라 관련성 상수나 임계값 등에 더 작은 값이 사용될 수 있어 체인에 성능은 증가합니다.
아직 다른 기준값들이 운용되는 실제 방법을 보이지는 않았으나 이들도 체인의 상태로부터 동적으로 조절됩니다.
알고리즘은 요구되는 목표값들을 기준으로 체인을 항상 일정한 수준으로 유지합니다.
이를 위해 현재 체인의 상태값들을 이용하여 기준값들을 조정합니다.
체인은 평균관련성 이외에도 평균전송시간을 주요한 상태값으로 갖습니다.
그리고 이 두 값을 이용하여 블록과 블록이 만날 때의 합의가 이루어집니다.

하나의 네트워크는 시간과 공간상에서 규모가 정해집니다.
네트워크를 구성하는 노드들이 있고 이 노드들 간에 전송시간이 있습니다.
이 전송시간은 위상학적 거리뿐만 아니라 전송매체의 품질이나 정책에 따른 제어에 의해서도 영향을 받습니다.
이 알고리즘에서는 체인에 새로운 블록이 추가되었을 때 바로 이전 블록과의 시간차를 전송시간으로 사용합니다.
이 시간에는 새로운 블록이 네트워크로 전송되기 바로 전에 어느 한 노드가 그 블록을 생성하기 위해 사용한 시간이 포함됩니다.
자체관련성과 마찬가지로 이 값도 각 노드에서 자체적으로 측정되어 사용되어지는 값으로 블록에 그 정보가 포함되지 않습니다.

각 노드는 각 순서번호에 해당하는 첫 블록이 각자의 체인에 추가될 때의 전송시간을 기록해 둡니다.
기록해 둔 후보블록들의 전송시간에 대한 산술평균으로부터 마지막 후보블록을 위한 실제의 평균전송시간을 구할 수 있습니다.

![averageTransmissionTimeFormula](https://raw.githubusercontent.com/ninanoo/PoR---Korean-Version/master/averageTransmissionTimeFormula.png "averageTransmissionTimeFormula")
```
n : sequence number
i : sequence number of first candidate block
j : sequence number of last candidate block
t : transmission time of candidate block
a' : average transmission time for the immediately previous candidate block
a : average transmission time for the last candidate block
```

단순히 산술평균을 이용하는 경우는 구현 시 첫 번째 후보블록과 마지막 후보블록을 받은 시간차를 전체 후보블록수로 나누어 구한 값과 같습니다.
두 경우 모두 마지막 후보블록을 위한 실제 평균전송시간은 바로 이전 후보블록을 위해 사용되었던 평균전송시간에 두 배를 차감하여 얻어집니다.
이 차감되어 지는 시간 값은 지역전송시간으로 지역화를 방지하기 위하여 알고리즘 규칙에 의해 만들어진 것입니다.
하나의 지역은 하나의 다음 후보블록이 생성될 수 있는 네트워크 공간상의 영역으로 합의가 진행되는 기본 단위 영역입니다.
평균전송시간은 어느 한 지역의 중앙에 위치한 노드의 신규 블록이 자신에 지역의 다른 모든 노드들에게 전송되는 시간의 평균값입니다.
네트워크에 노드들이 균일하게 분포되어있을 때 자신에 지역의 경계선까지 도달하는 데는 평균전송시간의 두 배인 지역전송시간에 해당하는 시간이 소요됩니다.
이 시간을 이용하여 지역의 내부와 외부가 구분이 되고 지역화가 방지됩니다.
어느 한 지역과 그 지역에 바로 인접한 주변의 모든 지역은 하나의 공간에서 위상차를 갖습니다.
이를 바꿔 기준이 되는 지역과 인접한 각 지역의 절반에 해당하는 영역들에 대해 각 영역을 기준으로 하는 하나의 절대공간에서 경쟁이 이루어지게 합니다.
위상차를 없애기 위해 같은 지역 내에서 발행되는 다음 블록은 바로 전의 지역전송시간에 해당하는 시간 지연을 갖습니다.
이 시간 지연을 만드는 방법은 이어지는 내용에서 설명됩니다.
이로 인해 어느 한 지역에서 하나의 블록이 추가되기 위해서는 실제 해당 지역의 네트워크에서 하나의 패킷을 전송하는데 걸리는 시간의 세 배가 소요됩니다.
이 지연에 대한 부분이 적용이 되어 위 식에서 실제 얻어지는 값은 어느 한 지역 내의 일반적인 패킷들에 대한 실제의 평균전송시간입니다.
이 지역 단위의 평균전송시간에 분기 지수에 해당하는 전체 지역의 수를 곱하면 전체 네트워크 단위에서의 평균전송시간을 구할 수 있습니다.
그리고 이 값은 다음 이슈 문서인 분기된 체인의 수렴 과정에 사용됩니다.

평균관련성과 마찬가지로 평균전송시간에서도 산술평균을 이용하였습니다.
통계적인 관점에서 알고리즘에 대한 분석이 더 진행되면 중앙값이나 최빈값과 같은 다른 종류의 대표값이 사용될 수도 있습니다.
네트워크에서 매우 먼 거리에 매우 낮은 품질의 전송매체를 갖는 하나의 노드가 있을 경우 정책에 의해 다르게 취급될 수도 있습니다.

산술평균을 구하기 위해 모든 후보블록들을 모집단으로 하여 하나의 값을 산출하는 것이 새로운 후보블록을 만드는데 가장 크게 수행되는 연산입니다.
후보블록체인만을 놓고 보면 하나의 큐와 같습니다.
인증블록으로 소모되는 경우는 후보블록체인의 출구에서 블록이 하나 제거됩니다.
새로운 후보블록으로 추가되는 경우는 후보블록체인의 입구에서 블록이 하나 추가됩니다.
실제 구현에서는 추가되거나 제외되는 하나의 블록에 대해서만 연산이 수행되도록 로직이 작성될 것입니다.
이를 통해 노드에서 다음 후보블록을 준비하는데 소요되는 로직의 수행시간을 최소로 합니다.
관련성에 의한 증명은 작업증명과 같은 시간 소모적인 연산을 수행하지 않습니다.
높은 클록을 갖는 고성능의 노드와 임베디드와 같은 저성능의 노드에서의 수행시간에 차이가 없습니다.
하나의 소유정보에 대해서는 병렬화도 의미가 없습니다.
노드에서의 수행시간이 무시할 수 있는 수준이므로 평균전송시간은 이를 포함합니다.
다른 부분의 세부 설계들에서도 선행처리나 지연처리가 가능하지 않은 구간에서 시간 소모적인 로직이 필요할 경우 공간을 더 사용하는 방법이 채택될 것입니다.
이를 위해 저가의 노드라 할지라도 어느 정도의 메모리 공간은 필요할 수 있습니다.
이는 다음 이슈 문서의 동기화 관련하여 사용될 분기된 체인 가지들의 캐싱을 위해서도 필요합니다.

네트워크의 공간과 시간상의 규모가 반영되도록 평균관련성과 평균전송시간이 사용됩니다.
난이도의 변경에 의한 네트워크의 공간 성능과 시간 성능은 배타적 관계에 놓입니다.
평균관련성과 평균전송시간을 이용하여 체인은 네트워크 규모의 변화에 적응해 나갑니다.
이들과 함께 체인의 동기화를 위해 순서번호가 사용됩니다.
최초의 제네시스 블록은 순서번호 0 을 사용합니다.
이후의 실제 사용되어질 블록들은 1 을 시작으로 1 씩 증가하는 순서번호를 갖습니다.
이어지는 내용에서는 이 모든 것들을 이용하여 하나의 후보블록을 송신하고 수신하는 절차가 설명됩니다.
새로운 블록이 각 노드의 메인 체인에 추가되는 절차를 통해 체인이 네트워크에 적응해 나가는 모습을 보입니다.
다른 체인 분기들에 해당하는 추가되는 블록들도 수신하나 이들을 받는 방법은 여기서 보이는 것과는 다릅니다.
이와 관련된 세부 내용은 다음 이슈 문서인 "체인 정보의 동기화"에서 다룹니다.

모든 노드는 다음 블록을 체인에 추가하기 위해 이전 블록의 해시값과 자신의 소유정보를 포함한 새 해시값을 구해 새로운 블록을 생성합니다.
이전 블록의 해시값과 새 블록의 해시값의 관련성이 현재 체인의 난이도와 같거나 크면 새로운 블록으로 체인에 추가하고 네트워크로 전송합니다.
새 블록을 발행하는 노드는 그 블록의 전송시간을 0 이 아닌 현재의 지역전송시간으로 기록합니다.
관련성이 난이도보다 작으면 다른 노드에서 생성한 블록을 받기 위해 대기합니다.
체인에 새로운 블록이 추가되기 전까진 자신이 생성한 블록을 버리지 않습니다.
이전 블록을 받은 이후로 현재 체인의 지역전송시간에 두 배의 시간이 경과할 때까지 새로운 블록을 받지 못하면 현재의 난이도를 1 비트 낮추어 새 난이도로 자신이 생성한 블록의 관련성과 다시 비교합니다.
난이도를 만족하면 전송하고 그렇지 못하면 다시 대기합니다.
또 한 번 지역전송시간에 두 배의 시간만큼이 경과할 때까지 추가되는 블록이 없으면 1 비트 낮아졌던 난이도를 다시 한 번 낮추고 같은 과정을 반복합니다.
이 과정은 난이도가 0 비트가 될 때까지 계속해서 진행되고 모든 노드에서 동일하게 진행됩니다.
난이도가 0 이 되면 모든 노드가 새로운 블록을 전송할 수 있게 됩니다.
현재 지역의 노드 수가 반영되는 난이도는 확률에 의한 값이므로 최악의 상황에는 위와 같은 경우도 발생할 수 있습니다.
1 비트씩 낮춤으로서 확률적 오차에 대해 두 노드에서 넷 그리고 여덟로 이전의 제곱에 해당하는 수의 노드들에게 다음 블록을 발행할 기회가 주어집니다.
다른 노드에 의해 다음 블록이 체인에 추가되면 변경된 체인으로 난이도와 평균전송시간을 다시 구하고 다음 순서번호의 블록에 대해 이 과정들을 다시 반복합니다.

확률적 오차에 의해 순간 낮아졌던 난이도가 다음 블록을 위한 난이도로 그대로 사용되지 않습니다.
난이도는 매번 전체 후보블록들의 대표값으로 새로 구해집니다.
그러나 새로 추가된 블록의 낮은 관련성은 다음에 구해질 난이도에 작게나마 반영이 됩니다.
체인은 네트워크 규모의 변화에 점진적으로 적응해 나갑니다.
길어진 평균전송시간도 마찬가지로 반영됩니다.
그러나 이는 논의의 여지가 있고 뒷부분에서 다시 다루어집니다.

보낼 때와 받을 때의 난이도는 운용방법이 다릅니다.
받을 때의 난이도는 처음부터 현재의 난이도에서 1 비트 높아진 난이도로 시작합니다.
시작 시간으로부터 지역전송시간만큼의 시간이 경과하면 난이도를 1 비트 낮춥니다.
그 이후로는 바로 전에 1 비트 낮아진 시간으로부터 지역전송시간에 두 배의 시간이 경과할 때 마다 1 비트씩 낮추어 나갑니다.
보낼 때와 마찬가지로 난이도가 0 이 될 때까지 계속해서 진행합니다.
받을 때의 난이도는 보낼 때의 난이도보다 지역전송시간만큼 지연되어 난이도가 낮아집니다.
이는 지역화를 방지합니다.
그러나 노드가 네트워크로부터 새로운 후보블록을 받는 기준은 보낼 때의 난이도입니다.
블록의 관련성이 받을 때의 난이도보다는 작고 보낼 때의 난이도보다는 크거나 같으면 버퍼에 임시 보관됩니다.
실제로 받을 때의 난이도는 새로운 후보블록을 체인에 추가하기 위한 합의를 진행할 때의 난이도입니다.

다음은 새로운 후보블록이 체인에 추가되는 상황을 보이기 위해 예로든 네트워크 구성으로 블록을 수신하는 절차를 확인할 수 있습니다.
네트워크에서 동일한 체인 분기에 속해있는 N1, N2, N3 의 세 노드가 있습니다.
현재 이 체인 분기는 보내기 위한 난이도인 D 와 받기 위한 난이도인 D + 1 그리고 T 의 지역전송시간을 갖습니다.
N2 는 N1 과 T * 0.3 시간에 해당하는 거리로 같은 지역에 있습니다.
N3 는 N1 과 T + ( T * 0.1 ) 시간에 해당하는 거리로 인접한 지역에 있습니다.

다음은 위와 같이 구성된 네트워크에서 난이도가 적용되는 예입니다.
N1 과 N3 에서 새로 생성된 블록은 보내기 위한 난이도인 D 보다 작아 두 노드는 다른 노드에서 생성된 블록을 받기 위해 대기합니다.
N2 에서 생성된 블록의 관련성은 난이도와 같은 D 값을 갖습니다.
해당 블록은 난이도를 만족하므로 N2 는 자신이 생성한 블록을 자신의 메인 체인에 추가합니다.
이전 블록을 받음과 동시에 새로운 블록을 생성하였으므로 이 블록을 실제 전송받은 시간은 0입니다.
그러나 지역화 방지를 위해 모든 블록의 전송받은 시간은 지역전송시간을 최소 시간으로 가지므로 0 이 아닌 이전 블록의 지역전송시간인 T 를 전송받은 시간으로 기록해둡니다.
이를 완료한 N2 는 이 블록을 네트워크로 전송합니다.
본문에 언급되지 않은 규칙 중 하나로 같은 소유정보를 갖는 두 블록이 하나의 체인 분기에서 인접하여 추가될 수 없습니다.
어느 한 노드가 체인에 자신의 블록을 연이어 추가할 수 없습니다.
그러므로 N2 는 연이어 다음 블록을 생성할 수 없어 다른 노드로부터 생성된 블록을 받기 위해 대기합니다.
N2 의 블록은 인접한 N1 에 먼저 도착합니다.
받은 블록의 관련성인 D 가 보내기 위한 관련성인 D 와는 같으나 아직 T 만큼의 시간이 경과하지 않아 받기 위한 난이도인 D + 1 보다는 작으므로 N1 은 이 블록을 버퍼에 임시 저장합니다.
그리고 이렇게 저장된 블록은 버퍼에 저장된 시점으로부터 지역전송시간인 T 만큼의 시간이 경과했을 때 버퍼에서 꺼내어져 합의가 진행됩니다.
N2 에 의해 새로운 블록이 네트워크로 보내진 이후로 T 만큼의 시간이 경과하였습니다.
받기 위한 난이도는 1 비트 작아진 D 가 되어 보내기 위한 난이도와 같아집니다.
이때 N2 의 후보블록이 T 시간만큼 떨어진 거리에 있던 N3 에 도착하게 되고 받은 블록의 관련성이 받기 위한 난이도와 같으므로 N3 는 이 블록을 자신의 메인 체인에 추가하고 받은 시간을 기록해둡니다.
N2 가 N1 의 블록을 버퍼에 임시 저장한 이후로 T 만큼의 시간이 경과하였습니다.
N2 는 버퍼에서 N1 의 블록을 꺼내어 다시 한 번 관련성을 확인합니다.
이때는 해당 블록의 관련성이 받기 위한 난이도와 같으므로 N1 도 N2 의 블록을 자신의 메인 체인에 추가하고 버퍼에서 꺼낸 현재 시간을 받은 시간으로 기록해둡니다.

다음은 처음에 가정한 네트워크에서 체인에 분기가 발생하는 예입니다.
N1 에서 생성된 다음 블록의 관련성은 보내기 위한 난이도인 D 보다 작습니다.
N1 은 다른 노드에서 생성된 블록을 받기 위해 대기합니다.
N2 와 N3 에서 생성된 다음 블록의 관련성은 난이도와 같은 D 값을 갖습니다.
두 블록 모두 난이도를 만족하므로 두 노드는 각각 자신이 생성한 블록을 각자의 체인에 추가한 후 네트워크로 전송합니다.
하나의 체인 분기가 둘로 다시 분기하였습니다.
N1 은 인접한 N2 의 블록을 먼저 받습니다.
받은 블록의 관련성인 D 가 보내기 위한 관련성인 D 와는 같으나 받기 위한 난이도인 D + 1 보다는 작으므로 N1 은 이 블록을 버퍼에 임시 저장합니다.
N1 에서 T 만큼의 시간이 경과하였습니다.
받기 위한 난이도는 1 비트 작아진 D 가 되어 보내기 위한 난이도와 같아집니다.
이때 T 시간만큼 떨어진 거리에 있던 N3 의 블록이 N1 에 도착하게 되고 해당 블록의 관련성이 받기 위한 난이도와 같으므로 N1 은 N3 의 블록을 체인에 추가합니다.
N1 이 N2 의 블록을 버퍼에 임시 저장한 이후로 T 만큼의 시간이 경과하였습니다.
N2 블록의 관련성이 받기 위한 난이도와 같으므로 N1 은 버퍼에서 N2 의 블록을 꺼낸 후 합의를 진행합니다.
N2 와 N3 블록의 관련성과 같고 N2 블록을 먼저 받았으나 N3 블록이 먼저 체인에 추가되었으므로 N1 의 메인 체인에는 N3 의 블록이 남습니다.

같은 메인 체인을 갖는 노드들은 같은 평균관련성을 갖으나 평균전송시간은 모든 노드에서 다릅니다.
위의 네트워크에서 각 노드의 지역전송시간이 아니라 하나의 지역전송시간인 T 를 사용한 것은 예제를 단순하게 만들려는 이유도 있으나 실제로 그렇게 동작하기 때문입니다.
인접한 지역 간의 노드들에 평균전송시간은 비록 정확하게 같지는 않으나 크게 차이가 나지는 않습니다.

N2 와 N3 의 관련성이 같을 때 N1 은 같은 지역의 N2 가 아닌 인접한 지역에 있는 N3 의 블록을 선택했습니다.
이는 지역화의 감소가 의도된 대로 작동된 예를 보인 것입니다.
N2 와 N1 사이의 시간 거리가 T * 0.1 이고 N3 와 N1 사이의 시간 거리가 T + ( T * 0.3 ) 이라면 N1 은 N2 의 블록을 선택하고 이 경우도 정당합니다.
그러나 N2 와 N1 사이의 시간 거리가 T * 0.1 이고 N3 와 N1 사이의 시간 거리가 T * 0.9 일 때도 N1 은 N2 의 블록을 선택합니다.
비록 N2 보다는 좀 더 먼 거리에 있으나 N3 또한 같은 지역에 있을 경우 이 지역만을 기준으로 보았을 때 지역화는 감소되지 않았습니다.
그러나 이 알고리즘은 전체 네트워크를 균일한 비율의 지역들로 나누므로 위 상황은 확률상의 오차 범주에 해당됩니다.

이 알고리즘에서 대부분의 기능 요소들은 확률적으로 동작합니다.
각 노드가 이전 후보블록을 받았던 시간 또한 다릅니다.
이런 연유로 우선은 이분법적으로 차등을 두는 단순한 방법을 사용합니다.
네트워크에는 N1 이외에도 N2 와 N3 로의 거리가 지역전송시간으로 구분되는 다른 많은 노드들이 있습니다.
각각의 이러한 모든 노드들에게 지역화의 감소 기능은 상대적으로 동작합니다.
전체 노드들이 각각의 전송시간을 거리로 하여 구체의 표면상에 균일하게 분포된 네트워크를 생각해 볼 수 있습니다.
분기 지수를 2 로 하여 두 개의 지역으로 운영될 때 지역화의 감소는 이 네트워크의 절반의 영역을 기준으로 동작합니다.
다음 블록을 발행할 수 있는 두 개의 노드가 구체에서 각각의 대척점에 놓여있을 경우 지역화의 감소는 가장 효과적으로 동작합니다.
이 경우 분기에 대한 분기는 확률상의 오차 범주에서 간헐적으로 발생합니다.
경쟁관계에 있는 두 지역만이 운영될 경우 블록과 블록이 만나는 상황에서 합의가 완료됩니다.
이 알고리즘에서 다음 블록을 발행할 노드는 균일한 분포를 갖는 난수에 기반을 두어 알고리즘에 의해 결정적으로 선출됩니다.
그로 인해 지역화의 감소에 대한 이분법적 접근은 계속되는 시간 속에서 유효하게 동작합니다.
지금 보인 것은 지역화를 완전하게 제거한 것이 아니라 확률적으로 감소시킨 것입니다.
알고리즘의 다른 세부설계들에서도 지역화를 감소시킬 또 다른 기법들이 고안될 것입니다.

최초 하나의 노드에서 시작된 네트워크에 다른 지역의 노드들이 하나씩 추가되어 네트워크가 점점 커지게 되면 일반적으로 평균전송시간과 노드 수에 해당하는 난이도가 함께 증가하게 됩니다.
그러나 두 값이 반드시 비례관계에 있는 것은 아닙니다.
네트워크가 성장해 나가는 형태에 따라 평균전송시간이 줄어들 수도 있습니다.
이 합의 알고리즘이 퍼블릭 블록체인으로 운용될 경우 각 나라의 정보통신망의 품질 수준이 다릅니다.
또한 이 합의 알고리즘에서는 한 개인에 의해 각각의 소유정보를 가진 값싼 저사양의 매우 많은 노드들이 운영되어 매우 짧은 평균전송시간을 갖는 지역들이 만들어질 수도 있습니다.
또는 하나의 고성능 장비에서 다수의 소유정보들에 대한 풀이 운영될 수도 있습니다.
그러나 이런 경우라 하더라도 작업증명에서와 같은 지역화로 인한 이윤의 극대화는 발생하지 않고 지출된 비용에 비례하는 이윤만이 만들어지므로 이는 정당한 개인의 노력으로 받아들여질 수 있습니다.
또한 실제 소유주나 실제 노드와 소유정보를 연결 짓는 방법 등은 사용되는 소유정보들의 특성에 따라 제어될 수 있고 하부 네트워크 단을 구현하는 단계에서도 고려되어질 수 있습니다.
이 알고리즘의 체인에는 모든 시간에 걸친 전체 네트워크의 정보가 담깁니다.
상위 블록일수록 이전 시간의 정보가 담기고 하위 블록일수록 최근의 정보가 담깁니다.
상위 블록일수록 전체 네트워크의 정보가 담기고 하위 블록일수록 지역의 정보가 담깁니다.
체인으로부터 얻어질 수 있는 이러한 정보들을 이용하여 네트워크 상태가 변화되는 추이를 추적할 수 있습니다.
이에 대한 변화량을 통계적으로 분석함으로서 체인을 각 구간별로 구분 지을 수 있고 이를 통해 물리 환경이 다른 각 지역 네트워크들에 대해 서로 다른 기준값으로 동작하게 할 수도 있습니다.
그러나 이러한 균일하지 못한 네트워크 환경으로 인해 지역에 대한 지역화가 발생할 수 있습니다.
이것도 알고리즘에 의해 관리되는 사항으로 다음 이슈 문서인 분기된 체인의 수렴에서 다루어집니다.

체인의 시간 성능은 인증블록의 발행 속도이고 합의 알고리즘의 성능은 여기에 블록 당 포함되는 원장의 수가 반영된 초당 트랜잭션 수(transactions per second)로서 측정됩니다.
이 알고리즘에서는 하나의 후보블록이 인증블록으로 소모된 후 보통의 경우 하나의 새로운 후보블록만이 체인에 추가되어도 다음 후보블록의 임계값이 만족되어 다음 인증블록이 발행됩니다.
한 지역의 평균전송시간을 기준으로 하나의 새로운 후보블록이 발행이 되고 이 시간 간격으로 하나의 인증블록이 발행될 수 있습니다.
한 지역의 평균전송시간이 1 초일 경우 10 분에 한 번 정도로 인증이 발행되는 작업증명과 비교하여 200 배 정도 더 높은 TPS를 갖습니다.
더 작은 난이도가 사용되어 1 밀리 초 정도의 평균전송시간을 가질 경우 작업증명의 200000 배 정도의 TPS를 갖습니다.
그러나 이 알고리즘에 대해서 아직은 몇 TPS 정도의 성능 수치를 갖는다고 말할 수 있는 단계는 아닙니다.
기본 합의에 대한 시스템이 설계되고 있을 뿐 기본 블록의 크기나 머클 트리(merkle tree)와 같은 원장에 대한 인증을 운영하는 방식 등에 대해서는 아직 정하여지지 않았습니다.
우선 구현되는 부분에서는 기존 블록체인들의 방식을 따를 것입니다.
하나의 인증블록이 발행되는 속도만을 놓고 보면 이 알고리즘은 작업증명과는 방식이 다르고 비교의 대상이 되지 못합니다.
이 알고리즘은 블록체인을 위한 모든 기능 요건들을 만족하면서 DAG 계열의 알고리즘들과 성능 비교가 가능합니다.
이 알고리즘에서 하나의 인증블록의 발행도 작업증명에서 하나의 블록이 발행되는 것과 같은 노력이 요구됩니다.
작업증명에서의 노력은 하나의 블록을 위해 10분의 시간이 소요되나 이 알고리즘에서는 하나의 후보블록이 임계값을 만족하기 위해 작은 경우라 하더라도 몇 시간이 소요됩니다.
작업증명에서는 한 노드의 노력만이 가치를 창출하고 나머지 모든 노드의 노력은 자원에 낭비로 버려지나 이 알고리즘에서는 모든 노드의 노력이 모여 시스템이 기능합니다.
하나의 블록에 포함된 노력의 양으로 보면 이 알고리즘에 하나의 블록은 작업증명의 블록과는 비교할 수 없는 많은 노력에 의해 만들어진 것입니다.
이와 같이 하나의 블록을 위해 많은 노력과 시간이 소요되면서도 인증의 발행은 빠른 속도로 이루어집니다.
빠른 해시 처리를 위한 고가의 장비가 필요한 것은 아니나 노드는 항상 네트워크에 연결되어 있어야 하고 현재의 전체 체인 정보에 동기화 되어있기 위해 끊임없이 네트워크로부터 전송되어오는 체인의 정보를 처리하여야 합니다.

블록과 블록이 만나는 경우에 대해 간단하게 코드로 구현해볼 수 있을 정도의 내용을 담으려 했으나 필요한 모든 내용이 담기지는 못했습니다.
확률적인 개념을 글로서 설명하기가 쉽지 않았고 시간상 깊은 내용을 넣지도 못했습니다.
개인적인 사정으로 아직은 이 프로젝트에 집중할 수 없어 두서없이 작성되었고 모호할 뿐만 아니라 잘못된 정보들도 있을 것입니다.
이 이슈 문서의 내용 관련하여 시간이 부족해 다 적지 못한 부분들은 여유가 되는 대로 추가 문서로 작성하려합니다.
머릿속에만 있던 세부적인 설계 내용들을 이제 막 적어보기 시작한 것으로 확률적인 추정 등에 잘못된 논리가 있을 수도 있습니다.
석사 과정으로 보안 관련 정보과 수업들을 들었으나 저는 확률론이나 네트워크를 전공한 자가 아닙니다.
전공과 비전공자를 불문하고 합의 알고리즘 자체나 블록체인의 또 다른 가능성 등에 관심 있으신 분들이 참여하시어 알고리즘이 발전할 수 있기를 바랍니다.
아직은 연구 프로젝트로 진행되고 있으나 구현될 수 있는 기회가 있기를 바랍니다.
다음 이슈 문서에서 분기된 체인의 수렴 방법을 보입니다.
느긋한 성격 탓에 언제쯤 작성될지는 알 수 없습니다.
체인의 수렴까지 먼저 설명이 되어야 전체 알고리즘이 어느 정도 보일 것이므로 가능하다면 시간이 되는대로 작성될 것 같습니다.
