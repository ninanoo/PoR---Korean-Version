##### ※ The English version of this article is [here](https://github.com/ninanoo/PoR).
##### ※ 변경 사항이나 추가되는 이슈들을 [페이스북](https://www.facebook.com/hcmoon82)에도 올리고 있습니다.

<br/>
<br/>

##### *This algorithm is a methodology for*
### *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A New Distributed Consensus and Distributed Ledger Technology*
##### *rather than just a proof of what.*

<br/>
<br/>
<br/>

> ### 이 알고리즘은 작업증명에 부족한 부분들을 개선하기 위해 연구되었습니다.
<br/>
지금에 블록체인은 노력에 대한 보상이라는 사회공학적 기법으로부터 정당한 과반수의 참여자를 보장받고 이 알고리즘도 그 틀 안에 있습니다.<br/>
그러나 이 알고리즘은 노드의 연산능력에 의한 작업량을 합의를 위한 선택의 기준으로 사용하지 않습니다.<br/>
작업증명에서는 각 노드에서의 반복 연산 수행을 통해 가장 관련성이 큰 하나의 블록이 만들어지나 이 알고리즘에서는 각 노드에서의 블록의 관련성이 유일하게 정하여지고 이 모든 블록 중 관련성이 가장 큰 하나의 블록을 전체 네트워크에서 찾습니다.<br/>
작업증명에서의 노력은 단일 노드에서의 높은 연산 수행 능력이나 이 알고리즘에서의 노력은 단일 노드가 체인에 대한 동기화 상태를 항상 높은 수준으로 유지하는 능력이고 이는 확률적입니다.<br/>
이를 위해 노드는 언제나 네트워크에 연결되어 있어야 하고 전송되는 프로토콜 패킷들을 성실히 처리하여야 합니다.<br/>
<br/>
작업증명에서 관련성이 가장 큰 블록은 0에 가장 가까운 해시값을 갖는 블록이나 이 알고리즘에서 관련성이 가장 큰 블록은 바로 이전 블록의 해시값에 가장 가까운 해시값을 갖는 블록입니다.<br/>
이 알고리즘에서의 관련성은 결정적이면서도 난수에 기반하여 패턴을 갖지 않는 값을 사용합니다.<br/>
그러나 실제 구현에서는 0에 가장 가까운 해시값이 선택의 기준으로 사용될 수 있고 이를 통해 작업증명 체인과의 연결점을 찾을 수도 있습니다.<br/>
<br/>
이 알고리즘도 작업증명과 같은 퍼블릭 블록체인으로 운용되는 것을 전제로 설계되었습니다.<br/>
그러나 중앙을 통한 새로운 소유정보의 생성 발급이나 이미 등록되어 보유하고 있는 정보를 소유정보로 사용함으로써 허가형 블록체인으로 운용될 수도 있습니다.<br/>
체인에 요구되는 성능이나 보안성 등에 맞추어 동작 관련 양적인 속성들이 동적으로 조절되고 합의에 참여하는 전체 노드들의 수나 노드 간의 전송시간과 같은 네트워크 상태와 관련된 속성들이 체인을 통해 확인될 수 있습니다.<br/>
이러한 특성들을 이용하여 폐쇄형이나 하이브리드 형태로 운용될 수도 있습니다.

<br/>
<br/>
<br/>
<br/>

> ### 이 알고리즘은 속도와 확장성 그리고 지역화를 해결하고 발행된 인증의 즉시성을 보장합니다.
<br/>
원장에 대한 인증이 실린 블록들로 구성된 하나의 체인이 운용되고 이 체인은 작업증명의 체인과 기능이 같습니다.<br/>
그러나 이 알고리즘에서는 아직 인증을 발행하지는 않았으나 그럴 자격을 갖춘 블록들로 구성된 또 하나의 체인이 운용됩니다.<br/>
이 후보 블록들로 구성된 체인의 첫 번째 블록에 의해 다음 원장에 대한 인증이 발행됩니다.<br/>
이를 통해 발행된 인증의 즉시성이 제공되고 발행의 속도가 보장됩니다.<br/>
<br/>
작업증명 체인의 각 블록은 바로 이전 블록으로의 단일 링크를 갖고 이 알고리즘의 체인도 같은 구조와 기능을 갖습니다.<br/>
그러나 이 알고리즘에서의 각 블록은 바로 이전이 아닌 훨씬 더 이전의 또 다른 블록으로의 링크를 하나 더 갖습니다.<br/>
이 또 다른 링크에 의해 하나의 연결 정보로 묶인 병렬화된 체인 구조가 만들어집니다.<br/>
실제 체인의 물리 구조는 다수로 병렬화된 분산 체인이나 논리 구조는 단일 체인을 유지합니다.<br/>
각 노드는 이 병렬화된 체인들 중 어느 한 체인의 정보만을 자신의 노드에 유지하고 이로 인해 공유 원장이 아닌 분산 원장으로서 기능합니다.<br/>
<br/>
작업증명에서는 무결함이 약속된 최초의 블록으로부터 이어지는 전체의 블록들에 의해 체인의 무결성이 보장됩니다.<br/>
그러나 이 알고리즘에서는 최근의 몇몇 인증 블록들과 현재의 후보 블록들만으로 체인 전체의 무결성이 보장됩니다.<br/>
과거의 참여자와 과거의 상태가 아닌 현재의 참여자와 현재의 상태로부터 보안성이 유지됩니다.<br/>
이를 통해 모든 원장에 대한 인증은 유효기간을 가질 수 있고 과거의 블록은 버려질 수 있습니다.<br/>
이 유효기간은 체인의 시간상에서의 확장성을 제공하고 분산 체인의 운용은 공간상에서의 확장성을 제공합니다.<br/>
<br/>
작업증명에서는 추가될 하나의 블록에 대해서만 합의가 진행됩니다.<br/>
그러나 이 알고리즘에서는 또 다른 하나의 체인으로 관리되는 후보 블록들 전체에 대해서 끊임없이 합의가 진행됩니다.<br/>
하나의 블록을 찾기 위해 다수의 합의가 전체 네트워크로 분산되어 진행되고 인증을 발행할 수 있기 전까진 합의에 대한 합의로서 계속해서 수렴됩니다.<br/>
하나의 합의가 아니라 후보 블록으로 존재하는 전체의 시간과 네트워크 전체의 공간에 분포하는 분산 합의가 이루어집니다.<br/>
이 시간과 공간에 대한 상관관계를 이용한 다양한 기법들이 사용되고 이를 통해 지역화가 점진적으로 감소합니다.<br/>
또한, 블록의 선출을 위한 합의와 인증의 발행이 긴 시간에 걸쳐 분리되어 진행되므로 알고리즘이 포크 없이 변경될 수 있고 전체 네트워크에 점진적으로 반영됩니다.

<br/>
<br/>
<br/>
<br/>

> ### 이 알고리즘이 목표하는 모든 세부적인 부분들까지의 설계가 완료되었습니다.
<br/>

기본 합의 방식에 대한 세부설계가 완료되었고 문서화가 이루어졌습니다.<br/>

[Basic consensus](https://github.com/ninanoo/PoR---Korean-Version/blob/master/BasicConsensus.md)<br/>
[Possibility of double spending](https://github.com/ninanoo/PoR---Korean-Version/blob/master/PossibilityOfDoubleSpending.md)<br/>
[Attempts to tamper with already confirmed authentication](https://github.com/ninanoo/PoR---Korean-Version/blob/master/AttemptsToTamperWithAlreadyConfirmedAuthentication.md)

위 문서들에서는 합의에 대한 이론적인 부분과 원장에 대한 인증 블록이 발행될 때의 기술적인 부분들이 다루어집니다.

<br/>

새로운 후보 블록의 추가에 대한 세부설계가 완료되었고 문서화가 이루어졌습니다.<br/>

[Addition of the next candidate block](https://github.com/ninanoo/PoR---Korean-Version/blob/master/AdditionOfTheNextCandidateBlock.md)

위 문서에서는 새로운 후보 블록이 후보 체인에 추가될 때 지역화를 감소시키는 기법이 소개됩니다.

<br/>

후보 체인의 동기화와 확장성을 위한 구조들에 대한 세부설계가 완료되었습니다.<br/>
그러나 이 두 기능에 대한 문서화는 아직 진행되지 않았습니다.<br/>
다른 기능들이 설계됨에 따라 기존에 작성된 문서들에서 수정될 부분들도 있으나 아직 진행되지 않았습니다.<br/>
영어 번역 문서를 병행하고 있어 알고리즘 설계보다 문서작성에 예상보다 많은 시간이 소요되었습니다.<br/>
문서작성이 목적이 아니기에 알고리즘을 더 쉽게 이해할 수 있기 위한 구현이 먼저 이루어질 수도 있습니다.<br/>
사업화를 위한 실제의 엔진 개발이 아니라 전체 알고리즘이 코드로 작성되고 간단하게 동작 방식이 보일 수 있을 정도의 구현입니다.<br/>
그래서 아직 문서로 작성되지 못한 부분들을 여기서 먼저 간략하게 소개합니다.

<br/>
<br/>

이 알고리즘의 후보 체인은 체인이 분기되는 것을 허용하여 트리 형태의 체인 구조가 만들어지고 체인의 아래쪽으로 갈수록 새로운 분기의 발생이 지수 증가합니다.<br/>
그러나 다음 인증을 발행할 첫 번째 후보 블록은 반드시 유일함이 보장되어야 하고 이를 위해 임계값에 해당하는 긴 시간에 걸쳐 후보 체인의 동기화가 진행됩니다.<br/>
처음 고안되었던 동기화 설계는 새로운 후보 블록의 추가에 맞추어 지역 단위로 분산되어 수렴되는 방식이었습니다.<br/>
그러나 최종 설계에서는 다음 인증 블록의 발행에 맞추어 동기화되는 방식으로 변경되었습니다.<br/>
이는 알고리즘을 더 단순하게 만들고 전체의 네트워크를 기준으로 분기된 체인들을 더 효율적으로 수렴시킵니다.<br/>
각각의 방식에 장단점이 있어 구현 단계에서는 두 방식이 혼합된 형태가 사용될 수도 있습니다.<br/>
<br/>
아래는 제임스, 엘리스, 루이스, 마리아 그리고 클라크의 다섯 참여자에 대한 그들 각 노드에서의 후보 체인입니다.<br/>

```
James  {00000} ~ {67372} - [67373]           ~ (77292)
Alice  {00000} ~ {67372} - (67373) ~ [75428] ~ (77362)
Lewis  {00000} ~ {67372} - (67373) ~ [74593] ~ (77290)
Maria  {00000} ~ {67372} - (67373) ~ [77285] ~ (77328)
Clark  {00000} ~ {67372} - (67373) ~ [77285] ~ (77311)
```

중괄호와 소괄호는 각각 인증 블록과 후보 블록이고 대괄호는 각 노드가 발행한 후보 블록입니다.<br/>
이 알고리즘의 블록 헤더에는 순서번호가 포함되고 위의 예에서는 그 순서번호만을 보였습니다.<br/>
최초 블록의 순서번호는 0번입니다.<br/>
현재 67372번의 인증 블록까지 발행이 되었고 모든 노드에서 동기화되어 있습니다.<br/>
리더 블록의 순서번호는 67373번으로 제임스가 소유주이고 모든 노드에서 동기화되어 있습니다.<br/>
다른 노드들은 각각 후보 체인의 어느 한 후보 블록을 발행하였습니다.<br/>
위의 후보 체인들은 전체 후보 체인에서 각각이 서로 다른 다섯 개의 체인 분기를 임의로 선정한 것입니다.<br/>
모두가 서로 다른 체인 분기에 속하므로 마지막으로 추가된 후보 블록들도 서로 다릅니다.<br/>
<br/>
아래는 트리 형태로 분기되는 전체 후보 체인에서 위 다섯 노드에서의 체인 분기들만을 모아서 보인 것입니다.<br/>

```
{00000}
   :
{67372}
   |
[67373]
   :
(74592)-------------
   |               |
(74593)         [74593]
   :               :
(75427)-----       :
   |       |       :
(75428) [75428]    :
   :       :       :
   :       :    (77284)-------------
   :       :       |       |       |
   :       :    (77285) [77285] [77285]
   :       :       :       :       :
   :       :    (77290)    :       :
(77292)    :               :       :
           :               :    (77311)
           :            (77328)
        (77362)

 James   Alice   Lewis   Maria   Clark
```

위에서 볼 수 있듯이 제임스를 제외한 다른 노드들은 모두 체인이 분기되는 지점의 첫 번째 후보 블록을 소유하고 있습니다.<br/>
분기를 발생시킨 이 블록들에 의해 분기된 체인의 동기화가 이루어집니다.<br/>
현재의 리더 블록인 67373번 블록을 소유한 제임스는 이 블록을 사용하여 다음 인증 블록을 발행합니다.<br/>
그리고 이때 자신의 후보 체인에 전체 블록인 67374번부터 77292번까지의 블록들의 헤더 정보를 하나로 묶어 인증 블록과 함께 발행합니다.<br/>
제임스의 후보 체인은 분기된 체인의 동기화를 위한 기준 체인으로 사용됩니다.<br/>
후보 블록의 헤더에는 아직 새 원장들과 그에 대한 인증 정보들이 포함되지 않았으므로 100바이트를 넘지 않습니다.<br/>
현재 체인의 경우 대략 10000개 정도의 후보 블록들로 유지되므로 전체 헤더 정보도 1MB를 넘지 않습니다.<br/>
새로운 인증 블록과 함께 새로운 기준 체인의 정보는 다른 네 노드에 임의의 순서로 도착합니다.<br/>
네 노드는 기준 체인과 각각 자신의 후보 체인을 비교합니다.<br/>
기준 체인과 비교하여 분기가 발생한 블록이 발견되면 해당 지점에서의 누적 관련성을 비교합니다.<br/>
기준 체인의 관련성이 더 높으면 자신의 후보 체인을 버리고 기준 체인을 새로운 후보 체인으로 선택합니다.<br/>
자신의 후보 체인의 관련성이 더 높으면 분기가 발생한 블록의 바로 이전의 블록부터 마지막 블록까지의 자신에 후보 블록들의 헤더 정보를 네트워크로 전송합니다.<br/>
이 정보는 다른 모든 노드에서 동기화를 위한 새로운 기준 정보로써 사용됩니다.<br/>
새로운 기준 정보들은 전체 네트워크에서 계속해서 연쇄하여 발생하고 체인의 분기들은 긴 시간에 걸쳐 단일 체인으로 수렴해 나갑니다.

<br/>
<br/>

이 알고리즘은 시간과 공간에 대한 각각의 확장성을 제공합니다.<br/>
체인이 운용되는 전체 시간에 대한 확장성을 제공하기 위해 원장의 인증에 대한 유효기간이 사용됩니다.<br/>
어느 한 시간대에서 네트워크 전체 공간에 대한 확장성을 제공하기 위해 인증 체인은 분산 체인으로 운용됩니다.<br/>
처음 고안되었던 공간에 대한 확장성 설계는 인증의 발행을 병렬화(pipelining)시키는 구조였습니다.<br/>
리더 블록은 처리할 원장에 대한 동기화만을 수행한 후 인증을 발행할 다른 블록들로 분배하는 방식으로 BFT(byzantine fault tolerance)와 DAG(directed acyclic graph)에서 사용되는 방식과 구조들이 일부 혼합된 형태였습니다.<br/>
이 방식은 인증 발행에 대한 처리량을 높여주고 한 줄기의 인증 체인을 병렬화된 다수의 체인으로 분산시켜줍니다.<br/>
그러나 이 방식은 하나의 원장에 대한 인증이 완료되기까지의 단일 응답시간을 길어지게 만들고 동기화를 위해 현재의 알고리즘에 많은 부분을 재설계되게 합니다.<br/>
최종 설계에서는 인증의 발행을 병렬화시키지 않습니다.<br/>
어느 한 시간에 단일 노드에 의해서만 인증이 발행되나 단일 인증 체인을 병렬화된 다수의 분산 체인으로 운영하여 공간상에서의 확장성을 제공합니다.<br/>
<br/>
<br/>

***( Within a few days, the scalability related contents would be written here... )***

<br/>
<br/>

이 알고리즘에는 세 종류의 시간에 대한 임계 블록들이 있습니다.<br/>
인증을 발행한 블록은 알고리즘의 동작에 관여하지 않으므로 이 임계 블록들은 모두 후보 블록입니다.<br/>
[첫 번째 문서](https://github.com/ninanoo/PoR---Korean-Version/blob/master/BasicConsensus.md)에서 후보 체인의 첫 번째 후보 블록인 리더 블록이 설명되었습니다.<br/>
이 블록은 자신을 뒤따르는 블록들에 의해 시간에 대한 제약을 받아 제외 처리될 수 있다고 설명되었습니다.<br/>
후보 체인에 앞부분의 대략 1/10에 해당하는 후보 블록들에 의해 리더 블록이 제외 처리될 수 있고 목표값들과 상태값들에 따라 이 블록들의 수에 해당하는 기준값이 정해진다고 설명되었습니다.<br/>
그러나 첫 설계와는 다르게 지금까지의 최종 설계에서는 이 블록들의 수에 제한을 두지 않습니다.<br/>
극단적인 실험 상황에서 하나의 리더 블록에 대한 제외 처리가 각 분기된 후보 체인의 서로 다른 후보 블록들에서 동시에 발생할 수 있고 네트워크 전체의 관점에서는 불확실성으로 여겨질 수 있습니다.<br/>
그러나 이 알고리즘에서는 체인에 분기가 하나의 순기능으로써 이용되고 알고리즘에 모든 기능은 각 분기에서 재귀적으로 동작합니다.<br/>
전체의 관점에서 불확실성은 공격을 더 어렵게 만드나 후보 블록들은 자신이 속한 후보 체인의 분기를 기준으로 하여 확률적으로 동작합니다.<br/>
이와 같은 시간에 대한 제약과 제외 처리 방식 등은 아직 문서로 작성되지 않은 다른 두 종류의 임계 블록들에도 마찬가지로 적용됩니다.<br/>
후보 체인의 동기화를 담당하는 각 분기 체인의 첫 번째 후보 블록이 있습니다.<br/>
인증 체인의 동기화를 담당하는 각 분산 체인의 첫 번째 후보 블록이 있습니다.<br/>
[최근 문서](https://github.com/ninanoo/PoR---Korean-Version/blob/master/AdditionOfTheNextCandidateBlock.md)에서 전체 네트워크 단위에서의 평균전송시간을 구하는 방법이 소개되었습니다.<br/>
이 두 경우에서의 제외 처리를 위한 시간 기준은 확률적인 추정에 의해 구해진 값이 사용됩니다.<br/>
세 경우에 대해 제외 처리를 위한 시간을 구하는 방법은 다르나 이러한 시간에 대한 규칙을 통해 체인은 영구히 동작합니다.

<br/>
<br/>
<br/>

> ### 이 알고리즘은 하나의 새로운 분산 합의 기술과 분산 원장 기술에 대한 설계입니다.
<br/>
아래는 일반적인 블록체인 응용 서비스들을 위해 이 알고리즘이 사용되는 방법론을 보여주는 계층화된 기술 스택입니다.<br/>
<br/>

```
*********************************************************************
*                    Decentralized Applications                     *
*********************************************************************
*               ?              *           Smart Contracts          *
*********************************************************************
*            Distributed Consensus and Distributed Ledger           *
*********************************************************************
```

스마트계약 옆의 비어있는 영역은 현재의 퍼블릭 블록체인 알고리즘들에서 구현하고 있는 토큰시스템입니다.<br/>
이 알고리즘은 가장 하위 계층인 분산 합의와 분산 원장에 대한 설계이고 토큰시스템과 스마트계약 그리고 분산애플리케이션에 대한 설계는 포함하지 않습니다.<br/>
이 알고리즘은 계층화된 구조(Layered Architecture)를 지향합니다.<br/>
가장 하위 계층의 기반 기술로 동작하면서 바로 위 계층인 토큰시스템과 스마트계약으로의 인터페이스를 제공합니다.<br/>
이 알고리즘을 위한 별도의 스마트계약이 설계될 수도 있으나 다른 블록체인 알고리즘의 스마트계약들이 모듈로써 제공될 수도 있습니다.<br/>
상위 계층의 서비스 특성에 따라 다양한 특성을 갖는 스마트계약들이 병행하여 사용될 수도 있습니다.<br/>
<br/>
노력에 대한 보상을 위해 반드시 토큰시스템이 필요한 것은 아닐 수도 있어 해당 영역을 이름 짓지 않았습니다.<br/>
현재의 토큰은 노력이라는 가치의 측정과 이동 그리고 저장 수단으로서 기능하고 있습니다.<br/>
화폐로서 기능하기 위해 별도의 데이터로 구체화 되어 실물화폐와 교환되고 있습니다.<br/>
그러나 토큰이라는 구체화 된 매개체가 없더라도 보상을 실현할 수 있는 기술적인 방법론들은 있습니다.<br/>
현실 세계에서 화폐가 생겨나기 이전에 동기식으로 가치를 교환하는 물물교환이 있었고 서로에 노동력을 교환하기 위한 약속이 있었으며 이는 비동기 방식으로 동작합니다.<br/>
그러나 현실 세계에서 가치를 관리하기 위한 가장 효율적인 방법론은 화폐이고 블록체인에서는 토큰 또는 코인입니다.<br/>
화폐로 기능하거나 그와 유사한 효과가 있는 것이 맞다 거나 틀렸다고 말할 수 있을 만큼 충분한 사회와 경제 지식을 갖추지는 못했으나 퍼블릭 블록체인으로 운용되기 위해서는 필요한 기능입니다.<br/>
토큰 발행을 위한 이 알고리즘의 관련된 구조적인 부분들이 다른 블록체인 알고리즘들의 구조와 크게 다르지 않습니다.<br/>
그러나 이 알고리즘은 보상에 대한 구조적인 설계를 포함하지 않고 연동되기 위한 인터페이스를 제공합니다.<br/>
이 마지막 단락만의 내용은 완료된 전체 아키텍처 설계에 대한 요약이 아니라 이 알고리즘에 적용하려는 방향성을 보인 것입니다.<br/>


<br/>
<br/>
<br/>

###### *I think the distributed consensus technology can be used for the social infrastructure<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;, which allows the will of the people to be fairly gathered,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rather than being used as a tool for someone to make money.<br/><br/>And I hope this algorithm can be used for it.*
