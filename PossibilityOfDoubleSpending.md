오늘 문서를 잠깐 살펴보다가 이중지불의 가능성이 발견되었습니다.

현재 설계된 부분은 하나 이상의 인증블록이 뒤따르거나 인증 확정을 위한 임계값을 사용하는 두 가지의 방법이 있었습니다.
그 중 더 안전한 방법인 하나 이상의 인증블록이 뒤따르면 인증이 확정되는 것으로 정하였습니다.

현재의 리더블록에 의해 이중지불이 시도되더라도 다음 리더블록이 선택한 하나의 인증블록만이 인증 확정되는 방식이었으나 현재의 리더블록과 다음 리더블록이 악의적인 목적으로 공모되었을 가능성이 있습니다.
극단적인 상황을 가정하면 악의적인 의도로 공모된 몇몇의 인접한 후보블록들에 의해 인증의 어느 한 구간에서 트리형태로 인증블록이 발행될 수 있습니다.
그러나 몇몇의 인접한 악의적인 후보블록들에 의한 이중지불 발행이 완료된 후 정당한 사용자인 다음 리더블록은 이중지불된 많은 인증블록들 중 하나의 블록만을 선택합니다.
이중지불에 대한 시도가 있었으나 체인은 계속해서 하나의 줄기로 유지됩니다.
그러나 이는 인증 확정을 위한 임계값을 사용하는 경우와 같은 상황이 됩니다.
이중지불이 발생했을 당시 체인에 추가되었던 후보블록들은 악의적으로 발행된 인증블록에 대한 참조를 갖게 됩니다.
새로 추가되는 후보블록이 마지막으로 확정되었던 인증블록에 대한 참조를 갖는 것은 현재는 보안성을 높이기 위한 것으로 기능에서 제외시킬 수도 있습니다.
그러나 둘 이상의 인접한 다수에 의한 이중지불 시도는 결재의 완료성을 보장할 수 없습니다.

형평성의 문제로 보았을 때 다른 알고리즘들의 경우와 비교하면 이 알고리즘에선 성공하기가 더 어렵습니다.
다른 알고리즘들의 경우엔 보상 관련하여 제재를 가하는 방법 등을 사용합니다.
그러나 이는 확률입니다.
악의적인 의도로 공모된 인접한 둘 이상의 후보블록들이 끊임없는 합의를 거쳐 리더블록의 자리까지 올 수 있을 확률로 0에 근접할 수는 있으나 0은 아닙니다.
악의적인 의도로 공모된 인접한 둘 이상의 후보블록들이 리더블록의 자리까지 오는 경우는 현실적으로 불가능하다는 것이 확률론의 관점에서 증명이 되어야 지금의 방식이 사용될 수 있습니다.
둘이 아니더라도 안전성이 보장될 수 있는 인접한 최소 블록수가 확률에 의해 산출이 되고 그에 해당하는 인증블록들이 뒤따를 때 인증이 확정될 수 있어야 합니다.
이 알고리즘은 참여를 위한 최초의 보상을 제외하고 부족한 기능을 보완하기 위한 보상은 가져가지 않는 것을 원칙으로 설계되었습니다.
모든 악의적인 시도나 예외적인 사항들이 알고리즘의 기본 동작에서 원천 차단되는 것을 목적으로 합니다.

지금의 방식이 확률적인 관점에서 안전하다고 증명되지 못한 경우에 대한 해결책으로 두 가지가 있습니다.

첫 번째 해결 방법은 위에서 잠깐 언급된 것으로 인증 확정을 위한 임계값을 갖는 것입니다.

이는 원안의 두 번째 방법이었던 새로 추가되는 후보블록들에 의한 인증 확정을 위한 임계값과는 다릅니다.
리더블록에 의해 인증블록이 발행되어야 할 때 악의적인 의도나 네트워크의 장애 상황을 고려하여 전체 후보블록의 1/10에 해당하는 블록들은 앞 후보블록들을 제외시킬 수 있는 제외 권한을 갖는 블록들로 정하였습니다.
제외 권한을 갖는 블록들의 수를 산출한 것과 마찬가지로 인증 확정을 위한 블록들의 수를 산출합니다.
하나의 인증블록이 발행된 후 인증 확정을 위한 블록들의 수에 해당하는 뒤따르는 인증블록들이 발행되면 해당 인증블록의 인증이 확정된 것으로 간주할 수 있습니다.
이는 제외 권한을 갖는 블록들의 수와 마찬가지로 확률에 의한 것으로 인증 확정을 완전하게 보장할 수 있는 블록들의 수를 얻기 위한 산출식이 만들어져야 합니다.
제외 권한의 경우는 악의적인 의도나 네트워크의 장애 상황에 의한 것이었으나 인증 확정의 경우에는 네트워크의 장애 상황은 해당 되지 않고 또한 반드시 인접하여 공모된 둘 이상의 블록들이 리더블록의 자리까지 와야 합니다.
그러므로 제외 권한을 갖는 블록들의 수 보다는 작은 값으로 알고리즘에서 사용되는 기준값들 중 가장 작은 값이 될 것입니다.
그러나 이 방법을 사용하면 원장에 대한 인증은 더 이상 결정적이지 않습니다.
비록 작다고는 하더라도 인증 확정에 적지 않은 시간이 소요될 수도 있습니다.
정확한 것은 인증 확정을 위한 산출식이 만들어지고 이를 통해 테스트가 진행되어야 합니다.

두 번째 해결 방법은 원안의 두 번째 방법이었던 인증 확정을 위한 임계값을 사용하는 것입니다.

원안에서는 새로 추가되는 후보블록이 아직 확정되지 않은 인증블록에 대한 참조를 포함하고 그 후보블록의 관련성이 인증 확정을 위한 임계값에 다다르면 해당 인증블록의 인증이 확정된 것으로 간주하였습니다.
그러나 여기서는 새로 추가되는 후보블록이 아직 확정되지 않은 인증블록에 대한 참조가 아니라 지금의 구조대로 마지막으로 확정된 인증블록의 참조를 포함합니다.
그 후보블록의 관련성이 인증 확정을 위한 임계값을 만족하면 해당 인증블록의 바로 뒤의 아직 확정되지 않은 인증블록의 인증이 확정된 것으로 간주합니다.
체인에 무결성은 지켜지나 첫 번째 해결 방법과 마찬가지로 인증 확정에 적지 않은 시간이 소요됩니다.

다른 방법으로는 최초의 블록부터 교차되어 이어지는 이중 서명을 사용하는 것을 생각해 볼 수 있습니다.

새 리더블록에 의해 인증블록이 발행됩니다.
그리고 뒤따르는 다음 리더블록이 아니라 이미 인증블록을 발행하여 확정을 받은 경험이 있는 현재 리더블록의 이전 리더블록이 이를 받습니다.
이전 리더블록은 새로 발행된 인증블록을 자신이 다시 한 번 인증하여 확정된 블록으로 발행합니다.
현재 리더블록의 다음 리더블록이 이를 받으면 위와 같은 과정으로 계속해서 진행됩니다.
이는 인증 확정의 이력이 있는 블록은 정당한 사용자라는 가정으로 인증 확정이 결정적으로 이루어지게 됩니다.
그러나 정당한 사용자가 아닐 수 있습니다.
자신에 악의적인 의도를 숨기고 있다가 다음 리더블록의 이중지불에 의해 발행된 두 개의 인증블록에 모두 서명할 수도 있습니다.
이 방법은 거래의 즉시성을 유지할 수 있으나 아직 문제가 있어 좀 더 충분히 생각이 되어야 합니다.

계산복잡도에 근거하는 알고리즘의 다른 부분들과 마찬가지로 이중지불 관련하여서도 확률로서 증명되어야 하는 부분입니다.
학교를 떠난 지 너무 오랜 시간이 흘러 혼자서 완성하기에는 부족한 부분들이 많습니다.
아직 학계에 남아 계시거나 확률을 다룰 수 있는 분들에 도움으로 부족한 부분들이 채워질 수 있기를 바랍니다.

저는 프리랜서 개발자로 혼자서 생각하여 모든 답을 만들어 내기에는 여건이 여의치 않습니다.
개인의 것이 아닌 많은 분들에 생각이 모아져 만들어지는 알고리즘이 되고 이것이 모두를 위하여 사용될 수 있기를 바랍니다.
